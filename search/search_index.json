{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Server-side Developer Documentation for Fabric Documentation for server-side modding with fabric","title":"Server-side Developer Documentation for Fabric"},{"location":"#server-side-developer-documentation-for-fabric","text":"Documentation for server-side modding with fabric","title":"Server-side Developer Documentation for Fabric"},{"location":"commands/","text":"Commands Commands are Minecraft's way of handling text-based user input outside of standard gameplay Registering a command In order to register commands, we first need to listen for Fabric API's command registration event. public class MyCommandsMod implements DedicatedServerModInitializer { @Override public void onInitializeServer() { CommandRegistrationCallback.EVENT.register(dispatcher, dedicated -> { // Add command registration code here }); } } Creating our command Minecraft commands use Mojang's brigadier library. Registering a basic command is as follows: public class MyCommandsMod implements DedicatedServerModInitializer { @Override public void onInitializeServer() { CommandRegistrationCallback.EVENT.register(dispatcher, dedicated -> { dispatcher.register( literal(\"mymodcommand\") .executes(ctx -> { ctx.getSource().getPlayer().sendMessage(new LiteralText(\"IT WORKS\"), false); return 1; }) ); }); } } If you now run your server and type /mymodcommand you will see a message appear in game chat! Arguments Above, you were introduced to basic registration of commands. We will now make our command more advanced: using arguments. public class MyCommandsMod implements DedicatedServerModInitializer { @Override public void onInitializeServer() { CommandRegistrationCallback.EVENT.register(dispatcher, dedicated -> { dispatcher.register( literal(\"mymodcommand\") .then(literal(\"subcommand\") .executes(ctx -> { ctx.getSource().getPlayer().sendMessage(new LiteralText(\"It works\"), false); return 1; }) ) ); }); } } /mymodcommand subcommand will now run the same as /mymodcommand had in the previous example But what does the code do? Let's take a look line-by-line dispatcher.register( This line tells Minecraft to register the command supplied in the argument of the register method. literal(\"mymodcommand\") Here we call CommandManager#literal with the argument \"mymodcommand\" . Literal means that the first part of the command is the string provided. .then(literal(\"subcommand\") We add the next part of the command, a string literal with the value subcommand . .executes(ctx -> { ctx.getSource().getPlayer().sendMessage(new LiteralText(\"It works!\"), false); return 1; }) .executes tells Minecraft to run the lambda block provided, taking one lambda parameter: an object of type CommandContext<ServerCommandSource> . It requires an integer to be returned. Formatting of commands It's suggested to indent your commands in a way that the various commands and arguments are clearly visible at a glance. IntelliJ's autoformatting tool (CTRL+ALT+L) will help with this. Non-String-Literal arguments String literals provide an excellent way to tell the game which command you are running, as you wouldn't type /minecraft:overworld . We do however want users to be able to enter their own information. Let's take a look at Mojang provided argument types. public class MyCommandsMod implements DedicatedServerModInitializer { @Override public void onInitializeServer() { CommandRegistrationCallback.EVENT.register(dispatcher, dedicated -> { dispatcher.register( literal(\"count\") .then(argument(\"number\", IntegerArgumentType.integer()) .executes(ctx -> { ctx.getSource().getPlayer().sendMessage(new LiteralText(\"You entered: \" + IntegerArgumentType.getInteger(ctx, \"count\")), false); return 1; }) ) .then(literal(\"subcommand\") .executes(ctx -> { ctx.getSource().getPlayer().sendMessage(new LiteralText(\"It works\"), false); return 1; }) ) ); }); } } As you can see, we duplicated our code and replaced the string literal with a call to CommandManager#argument , providing the name of the argument and the type of the argument. We then obtain that argument using the CommandContext provided in our lambda. This would leave you with the option of the two commands below: /count subcommand -> \"It works\" /count <count> -> \"You entered: \" Arguments Types Vanilla provides many argument types to use in commands. It's also possible to register your own argument types, but this does not work serverside. You can create pseudo argument types with a string argument type and a custom suggester. Vanilla Argument Types EntityArgumentType GameProfileArgumentType BlockPosArgumentType ColumnPosArgumentType Vec3ArgumentType Vec2ArgumentType BlockStateArgumentType BlockPredicateArgumentType ItemStackArgumentType ItemPredicateArgumentType ColorArgumentType TextArgumentType MessageArgumentType NbtCompoundArgumentType NbtElementArgumentType NbtPathArgumentType ScoreboardObjectiveArgumentType ScoreboardCriterionArgumentType OperationArgumentType ParticleEffectArgumentType AngleArgumentType RotationArgumentType ScoreboardSlotArgumentType ScoreHolderArgumentType SwizzleArgumentType TeamArgumentType ItemSlotArgumentType IdentifierArgumentType StatusEffectArgumentType CommandFunctionArgumentType EntityAnchorArgumentType IntRangeArgumentType FloatRangeArgumentType EnchantmentArgumentType EntitySummonArgumentType DimensionArgumentType TimeArgumentType UuidArgumentType Congratulations! You learnt how to create a command in your mod. You can now learn to add permission checks to your commands on the Permissions page","title":"Commands"},{"location":"commands/#commands","text":"Commands are Minecraft's way of handling text-based user input outside of standard gameplay","title":"Commands"},{"location":"commands/#registering-a-command","text":"In order to register commands, we first need to listen for Fabric API's command registration event. public class MyCommandsMod implements DedicatedServerModInitializer { @Override public void onInitializeServer() { CommandRegistrationCallback.EVENT.register(dispatcher, dedicated -> { // Add command registration code here }); } }","title":"Registering a command"},{"location":"commands/#creating-our-command","text":"Minecraft commands use Mojang's brigadier library. Registering a basic command is as follows: public class MyCommandsMod implements DedicatedServerModInitializer { @Override public void onInitializeServer() { CommandRegistrationCallback.EVENT.register(dispatcher, dedicated -> { dispatcher.register( literal(\"mymodcommand\") .executes(ctx -> { ctx.getSource().getPlayer().sendMessage(new LiteralText(\"IT WORKS\"), false); return 1; }) ); }); } } If you now run your server and type /mymodcommand you will see a message appear in game chat!","title":"Creating our command"},{"location":"commands/#arguments","text":"Above, you were introduced to basic registration of commands. We will now make our command more advanced: using arguments. public class MyCommandsMod implements DedicatedServerModInitializer { @Override public void onInitializeServer() { CommandRegistrationCallback.EVENT.register(dispatcher, dedicated -> { dispatcher.register( literal(\"mymodcommand\") .then(literal(\"subcommand\") .executes(ctx -> { ctx.getSource().getPlayer().sendMessage(new LiteralText(\"It works\"), false); return 1; }) ) ); }); } } /mymodcommand subcommand will now run the same as /mymodcommand had in the previous example","title":"Arguments"},{"location":"commands/#but-what-does-the-code-do","text":"Let's take a look line-by-line dispatcher.register( This line tells Minecraft to register the command supplied in the argument of the register method. literal(\"mymodcommand\") Here we call CommandManager#literal with the argument \"mymodcommand\" . Literal means that the first part of the command is the string provided. .then(literal(\"subcommand\") We add the next part of the command, a string literal with the value subcommand . .executes(ctx -> { ctx.getSource().getPlayer().sendMessage(new LiteralText(\"It works!\"), false); return 1; }) .executes tells Minecraft to run the lambda block provided, taking one lambda parameter: an object of type CommandContext<ServerCommandSource> . It requires an integer to be returned.","title":"But what does the code do?"},{"location":"commands/#formatting-of-commands","text":"It's suggested to indent your commands in a way that the various commands and arguments are clearly visible at a glance. IntelliJ's autoformatting tool (CTRL+ALT+L) will help with this.","title":"Formatting of commands"},{"location":"commands/#non-string-literal-arguments","text":"String literals provide an excellent way to tell the game which command you are running, as you wouldn't type /minecraft:overworld . We do however want users to be able to enter their own information. Let's take a look at Mojang provided argument types. public class MyCommandsMod implements DedicatedServerModInitializer { @Override public void onInitializeServer() { CommandRegistrationCallback.EVENT.register(dispatcher, dedicated -> { dispatcher.register( literal(\"count\") .then(argument(\"number\", IntegerArgumentType.integer()) .executes(ctx -> { ctx.getSource().getPlayer().sendMessage(new LiteralText(\"You entered: \" + IntegerArgumentType.getInteger(ctx, \"count\")), false); return 1; }) ) .then(literal(\"subcommand\") .executes(ctx -> { ctx.getSource().getPlayer().sendMessage(new LiteralText(\"It works\"), false); return 1; }) ) ); }); } } As you can see, we duplicated our code and replaced the string literal with a call to CommandManager#argument , providing the name of the argument and the type of the argument. We then obtain that argument using the CommandContext provided in our lambda. This would leave you with the option of the two commands below: /count subcommand -> \"It works\" /count <count> -> \"You entered: \"","title":"Non-String-Literal arguments"},{"location":"commands/#arguments-types","text":"Vanilla provides many argument types to use in commands. It's also possible to register your own argument types, but this does not work serverside. You can create pseudo argument types with a string argument type and a custom suggester.","title":"Arguments Types"},{"location":"commands/#vanilla-argument-types","text":"EntityArgumentType GameProfileArgumentType BlockPosArgumentType ColumnPosArgumentType Vec3ArgumentType Vec2ArgumentType BlockStateArgumentType BlockPredicateArgumentType ItemStackArgumentType ItemPredicateArgumentType ColorArgumentType TextArgumentType MessageArgumentType NbtCompoundArgumentType NbtElementArgumentType NbtPathArgumentType ScoreboardObjectiveArgumentType ScoreboardCriterionArgumentType OperationArgumentType ParticleEffectArgumentType AngleArgumentType RotationArgumentType ScoreboardSlotArgumentType ScoreHolderArgumentType SwizzleArgumentType TeamArgumentType ItemSlotArgumentType IdentifierArgumentType StatusEffectArgumentType CommandFunctionArgumentType EntityAnchorArgumentType IntRangeArgumentType FloatRangeArgumentType EnchantmentArgumentType EntitySummonArgumentType DimensionArgumentType TimeArgumentType UuidArgumentType Congratulations! You learnt how to create a command in your mod. You can now learn to add permission checks to your commands on the Permissions page","title":"Vanilla Argument Types"},{"location":"events/","text":"Events Events provide a way of running code when a certain action happens Fabric's API has the following groups of events: Lifecycle events Interaction events Networking events For this example, we will use the lifecycle events module. Registering the callback When you want to listen for an event, you register a bit of code that will run whenever the event is triggered. Listening for the server starting event would be as follows: public class MyMod implements DedicatedServerModInitializer { @Override public void onInitializeServer() { ServerLifecycleEvents.SERVER_STARTING.register(server -> { System.out.println(\"SERVER STARTING\"); }); } } The server starting event is defined within ServerLifecycleEvents in a field named SERVER_STARTING . We then register using the SERVER_STARTING event, which requires a lambda expression with a single MinecraftServer parameter. What is MinecraftServer ? If you have ever written a plugin for the Bukkit API, you will know that you interact with the API, not the game. This is not the case on Fabric. MinecraftServer is the name of the class that is, well, the Minecraft Server in use at the time. As you progress through this guide, we will show you many of the methods that this class contains. However, as the is so much in this class, we will not be able to cover all of its features - and this is a recurring theme. For this reason, if you are looking for something, IDE tab completion will be your friend. If you ever have issues, you can ask on the Fabric Server-side Development Discord server . The simplest way to put it is: you will know how to do more the more time you spend playing around. More uses of events You can register events anywhere, and have whatever logic you want run when they are called. Let's look at a more complex example. public class MyMod implements DedicatedServerModInitializer { @Override public void onInitializeServer() { registerServerStarted(); ServerLifecycleEvents.SERVER_STOPPING.register(server -> onServerStop(server)); } public void registerServerStarted() { ServerLifecycleEvents.SERVER_STARTED.register(server -> { if (server.getPlayerManager().getPlayerList().isEmpty()) { System.out.println(\"SERVER STARTING\"); } }); } private void onServerStop(MinecraftServer server) { System.out.println(\"SERVER STOPPING\"); } } Fabric Wiki This page also has an alternative on the Fabric wiki , although it is very out of date.","title":"Events"},{"location":"events/#events","text":"Events provide a way of running code when a certain action happens Fabric's API has the following groups of events: Lifecycle events Interaction events Networking events For this example, we will use the lifecycle events module.","title":"Events"},{"location":"events/#registering-the-callback","text":"When you want to listen for an event, you register a bit of code that will run whenever the event is triggered. Listening for the server starting event would be as follows: public class MyMod implements DedicatedServerModInitializer { @Override public void onInitializeServer() { ServerLifecycleEvents.SERVER_STARTING.register(server -> { System.out.println(\"SERVER STARTING\"); }); } } The server starting event is defined within ServerLifecycleEvents in a field named SERVER_STARTING . We then register using the SERVER_STARTING event, which requires a lambda expression with a single MinecraftServer parameter.","title":"Registering the callback"},{"location":"events/#what-is-minecraftserver","text":"If you have ever written a plugin for the Bukkit API, you will know that you interact with the API, not the game. This is not the case on Fabric. MinecraftServer is the name of the class that is, well, the Minecraft Server in use at the time. As you progress through this guide, we will show you many of the methods that this class contains. However, as the is so much in this class, we will not be able to cover all of its features - and this is a recurring theme. For this reason, if you are looking for something, IDE tab completion will be your friend. If you ever have issues, you can ask on the Fabric Server-side Development Discord server . The simplest way to put it is: you will know how to do more the more time you spend playing around.","title":"What is MinecraftServer?"},{"location":"events/#more-uses-of-events","text":"You can register events anywhere, and have whatever logic you want run when they are called. Let's look at a more complex example. public class MyMod implements DedicatedServerModInitializer { @Override public void onInitializeServer() { registerServerStarted(); ServerLifecycleEvents.SERVER_STOPPING.register(server -> onServerStop(server)); } public void registerServerStarted() { ServerLifecycleEvents.SERVER_STARTED.register(server -> { if (server.getPlayerManager().getPlayerList().isEmpty()) { System.out.println(\"SERVER STARTING\"); } }); } private void onServerStop(MinecraftServer server) { System.out.println(\"SERVER STOPPING\"); } }","title":"More uses of events"},{"location":"events/#fabric-wiki","text":"This page also has an alternative on the Fabric wiki , although it is very out of date.","title":"Fabric Wiki"},{"location":"libraries/","text":"Libraries and APIs If you have a program you want to write which shares common code with other programs, what would you do? Luckily, this has already been decided. You put your common code in a library for other people to use. Adding a Library or API For this tutorial, we will be adding the Fabric Permissions API , which is the most common permissions API in use with Fabric server-side mods. Locate Artifact Location You will need to find the maven repository that your library is on. In the case of the Fabric Permissions API, the location is https://oss.sonatype.org/content/repositories/snapshots Add Repository Locate the repositories block in your build.gradle : repositories { } You now need to add the maven repository's URL to the section: repositories { maven { url = \"https://oss.sonatype.org/content/repositories/snapshots\" } } Add to build.gradle Mod Libraries or APIs Find the dependencies block in your build.gradle : dependencies { // To change the versions see the gradle.properties file minecraft \"com.mojang:minecraft:${project.minecraft_version}\" mappings \"net.fabricmc:yarn:${project.yarn_mappings}:v2\" modImplementation \"net.fabricmc:fabric-loader:${project.loader_version}\" // Fabric API. This is technically optional, but you probably want it anyway. modImplementation \"net.fabricmc.fabric-api:fabric-api:${project.fabric_version}\" } Add the following line in the block: modImplementation(include(\"library.package:library-name:library-version\")) This will tell Gradle to add our library and when you export your mod, it will add the library inside the produced jar file. If your library is a mod which is intended to be downloaded on its own, such as fabric-language-kotlin, you should exclude the include() block. In the case of the permissions API, we need to add modImplementation(include('me.lucko:fabric-permissions-api:0.1-SNAPSHOT')) Non-Mod Libraries or APIs Find the dependencies block in your build.gradle : dependencies { // To change the versions see the gradle.properties file minecraft \"com.mojang:minecraft:${project.minecraft_version}\" mappings \"net.fabricmc:yarn:${project.yarn_mappings}:v2\" modImplementation \"net.fabricmc:fabric-loader:${project.loader_version}\" // Fabric API. This is technically optional, but you probably want it anyway. modImplementation \"net.fabricmc.fabric-api:fabric-api:${project.fabric_version}\" } Add the following line in the block: implementation(include(\"library.package:library-name:library-version\")) This will tell Gradle to add our library and include the library when the mod is exported Once you have added your library, you will see a button to refresh Gradle. Press this, and your library is now added!","title":"Libraries and APIs"},{"location":"libraries/#libraries-and-apis","text":"If you have a program you want to write which shares common code with other programs, what would you do? Luckily, this has already been decided. You put your common code in a library for other people to use.","title":"Libraries and APIs"},{"location":"libraries/#adding-a-library-or-api","text":"For this tutorial, we will be adding the Fabric Permissions API , which is the most common permissions API in use with Fabric server-side mods.","title":"Adding a Library or API"},{"location":"libraries/#locate-artifact-location","text":"You will need to find the maven repository that your library is on. In the case of the Fabric Permissions API, the location is https://oss.sonatype.org/content/repositories/snapshots","title":"Locate Artifact Location"},{"location":"libraries/#add-repository","text":"Locate the repositories block in your build.gradle : repositories { } You now need to add the maven repository's URL to the section: repositories { maven { url = \"https://oss.sonatype.org/content/repositories/snapshots\" } }","title":"Add Repository"},{"location":"libraries/#add-to-buildgradle","text":"","title":"Add to build.gradle"},{"location":"libraries/#mod-libraries-or-apis","text":"Find the dependencies block in your build.gradle : dependencies { // To change the versions see the gradle.properties file minecraft \"com.mojang:minecraft:${project.minecraft_version}\" mappings \"net.fabricmc:yarn:${project.yarn_mappings}:v2\" modImplementation \"net.fabricmc:fabric-loader:${project.loader_version}\" // Fabric API. This is technically optional, but you probably want it anyway. modImplementation \"net.fabricmc.fabric-api:fabric-api:${project.fabric_version}\" } Add the following line in the block: modImplementation(include(\"library.package:library-name:library-version\")) This will tell Gradle to add our library and when you export your mod, it will add the library inside the produced jar file. If your library is a mod which is intended to be downloaded on its own, such as fabric-language-kotlin, you should exclude the include() block. In the case of the permissions API, we need to add modImplementation(include('me.lucko:fabric-permissions-api:0.1-SNAPSHOT'))","title":"Mod Libraries or APIs"},{"location":"libraries/#non-mod-libraries-or-apis","text":"Find the dependencies block in your build.gradle : dependencies { // To change the versions see the gradle.properties file minecraft \"com.mojang:minecraft:${project.minecraft_version}\" mappings \"net.fabricmc:yarn:${project.yarn_mappings}:v2\" modImplementation \"net.fabricmc:fabric-loader:${project.loader_version}\" // Fabric API. This is technically optional, but you probably want it anyway. modImplementation \"net.fabricmc.fabric-api:fabric-api:${project.fabric_version}\" } Add the following line in the block: implementation(include(\"library.package:library-name:library-version\")) This will tell Gradle to add our library and include the library when the mod is exported Once you have added your library, you will see a button to refresh Gradle. Press this, and your library is now added!","title":"Non-Mod Libraries or APIs"},{"location":"mixin-injects/","text":"Mixin Injects Mixin is a powerful tool used for bytecode transformation - specifically modifying the Minecraft source code in a way that prevents as many conflicts as possible between mods. Let's take a look at an example. Mixin triggered whenever a block is broken @Mixin(Block.class) public class MixinBlock { @Inject(at = @At(\"HEAD\"), method = \"onBreak\") public void onBreak(World world, BlockPos pos, BlockState state, PlayerEntity player, CallbackInfo info) { player.sendMessage(new LiteralText(\"You broke \" + Registry.BLOCK.getId(state.getBlock())), false); } } This is considerably more complex than anything shown so far. But what does it do? @Mixin(Block.class) This tells the compiler that this is a mixin class, targeting the class net.minecraft.block.Block . @Inject(at = @At(\"HEAD\"), method = \"onBreak\") @Inject is a Mixin annotation. It tells the Mixin runtime to \"inject\" the logic of our method into the onBreak method we specified with the method argument. The at = @At(\"HEAD\") part means that our code will be injected at the top of the method; making it the first thing to run run when that method is called. We then have a method with the same arguments as our target method, plus a CallbackInfo object. Registering Mixins When you add a mixin, you must put the mixin class in <your_package>.mixin . Then, you should add an entry to the server array in your <your_modid>.mixins.json file with the name of your mixin class. Any mixins listed in the server array will only be loaded on a dedicated server. Fabric Wiki Confused? The fabric wiki has a very extensive guide to mixins Mixin cheatsheet The Mixin cheatsheet has guides and examples for every type of mixin. If you want to learn how to do more than injecting at the top of a method, I would advise checking it out. Game code used in the example LiteralText : new LiteralText(String text) - this creates a Text object with the value of the string passed. Text : a class representing a message that can be sent to a player through chat. Contains colour information, the string literal, or potentially a translation key. PlayerEntity#sendMessage(Text text, boolean actionBar) : Sends the player a message with the text component provided in the arguments. actionBar should nearly always be false","title":"Mixin Injects"},{"location":"mixin-injects/#mixin-injects","text":"Mixin is a powerful tool used for bytecode transformation - specifically modifying the Minecraft source code in a way that prevents as many conflicts as possible between mods. Let's take a look at an example.","title":"Mixin Injects"},{"location":"mixin-injects/#mixin-triggered-whenever-a-block-is-broken","text":"@Mixin(Block.class) public class MixinBlock { @Inject(at = @At(\"HEAD\"), method = \"onBreak\") public void onBreak(World world, BlockPos pos, BlockState state, PlayerEntity player, CallbackInfo info) { player.sendMessage(new LiteralText(\"You broke \" + Registry.BLOCK.getId(state.getBlock())), false); } } This is considerably more complex than anything shown so far. But what does it do? @Mixin(Block.class) This tells the compiler that this is a mixin class, targeting the class net.minecraft.block.Block . @Inject(at = @At(\"HEAD\"), method = \"onBreak\") @Inject is a Mixin annotation. It tells the Mixin runtime to \"inject\" the logic of our method into the onBreak method we specified with the method argument. The at = @At(\"HEAD\") part means that our code will be injected at the top of the method; making it the first thing to run run when that method is called. We then have a method with the same arguments as our target method, plus a CallbackInfo object.","title":"Mixin triggered whenever a block is broken"},{"location":"mixin-injects/#registering-mixins","text":"When you add a mixin, you must put the mixin class in <your_package>.mixin . Then, you should add an entry to the server array in your <your_modid>.mixins.json file with the name of your mixin class. Any mixins listed in the server array will only be loaded on a dedicated server.","title":"Registering Mixins"},{"location":"mixin-injects/#fabric-wiki","text":"Confused? The fabric wiki has a very extensive guide to mixins","title":"Fabric Wiki"},{"location":"mixin-injects/#mixin-cheatsheet","text":"The Mixin cheatsheet has guides and examples for every type of mixin. If you want to learn how to do more than injecting at the top of a method, I would advise checking it out.","title":"Mixin cheatsheet"},{"location":"mixin-injects/#game-code-used-in-the-example","text":"LiteralText : new LiteralText(String text) - this creates a Text object with the value of the string passed. Text : a class representing a message that can be sent to a player through chat. Contains colour information, the string literal, or potentially a translation key. PlayerEntity#sendMessage(Text text, boolean actionBar) : Sends the player a message with the text component provided in the arguments. actionBar should nearly always be false","title":"Game code used in the example"},{"location":"nbt/","text":"NBT NBT is the way Minecraft stores information for multiple things: entity data, world storage, items and many more features are all powered by NBT. Introduction Let's start by creating an empty NBT tag NbtCompound nbt = new NbtCompound(); Here we register a variable, nbt , and make it an empty NBT object. Let's add some information: NbtCompound myInformation = new NbtCompound(); myInformation.putInt(\"age\", 69); myInformation.putString(\"name\", \"nbt tutorial\"); We have now added an integer value, age, to our object. We also add a string value, called name. But you may be wondering: isn't this just glorified JSON? Well in essence, yes. NBT has many similarities with JSON. If you know how to use JSON, NBT should be trivial to pick up. Like JSON, we can also add objects as the value: myInformation.putInt(\"profile\", new NbtCompound()); This line would put an empty object as the profile value. Below is a representation of what we have done, in JSON: { \"age\": 69, \"name\": \"nbt tutorial\", \"profile\": { } } You can also read from NBT objects: String name = myInformation.getString(\"name\"); NbtCompound profile = myInformation.get(\"profile\"); Practical use All this is great, but we actually need to use it. So, how? This code sample will take the NBT from a hopper and will print it to the console: public class NbtTutorial { public static void printNbt(HopperBlockEntity hopper) { NbtCompound nbt = hopper.writeNbt(new NbtCompound()); System.out.println(nbt.toString()); } } writeNbt(NbtCompound) writes the entity data to the NBT tag provided in the argument Not to be confused with readNbt(NbtCompound) , which writes the data from the NBT tag to the entity","title":"NBT"},{"location":"nbt/#nbt","text":"NBT is the way Minecraft stores information for multiple things: entity data, world storage, items and many more features are all powered by NBT.","title":"NBT"},{"location":"nbt/#introduction","text":"Let's start by creating an empty NBT tag NbtCompound nbt = new NbtCompound(); Here we register a variable, nbt , and make it an empty NBT object. Let's add some information: NbtCompound myInformation = new NbtCompound(); myInformation.putInt(\"age\", 69); myInformation.putString(\"name\", \"nbt tutorial\"); We have now added an integer value, age, to our object. We also add a string value, called name. But you may be wondering: isn't this just glorified JSON? Well in essence, yes. NBT has many similarities with JSON. If you know how to use JSON, NBT should be trivial to pick up. Like JSON, we can also add objects as the value: myInformation.putInt(\"profile\", new NbtCompound()); This line would put an empty object as the profile value. Below is a representation of what we have done, in JSON: { \"age\": 69, \"name\": \"nbt tutorial\", \"profile\": { } } You can also read from NBT objects: String name = myInformation.getString(\"name\"); NbtCompound profile = myInformation.get(\"profile\");","title":"Introduction"},{"location":"nbt/#practical-use","text":"All this is great, but we actually need to use it. So, how? This code sample will take the NBT from a hopper and will print it to the console: public class NbtTutorial { public static void printNbt(HopperBlockEntity hopper) { NbtCompound nbt = hopper.writeNbt(new NbtCompound()); System.out.println(nbt.toString()); } } writeNbt(NbtCompound) writes the entity data to the NBT tag provided in the argument Not to be confused with readNbt(NbtCompound) , which writes the data from the NBT tag to the entity","title":"Practical use"},{"location":"permissions/","text":"Permissions This tutorial shows how to handle and check permissions. Setup You will need to have set up the Fabric Permissions API in your environment. See the libraries page Command Permissions Here is our command without a permission check: public class MyCommandsMod implements DedicatedServerModInitializer { @Override public void onInitializeServer() { CommandRegistrationCallback.EVENT.register(dispatcher, dedicated -> { dispatcher.register( literal(\"mymodcommand\") .then(literal(\"subcommand\") .executes(ctx -> { ctx.getSource().getPlayer().sendMessage(new LiteralText(\"It works\"), false); return 1; }) ) ); }); } } This allows any player on the server to use /mymodcommand . But in many cases, we want to restrict who can run the command Permission Levels Every player has a permission level. Here is a non-extensive list of standard values: Standard player: 0 Command blocks: 2 Operator: Specified in server.properties , default 4 What do the levels allow? 0: Normal non-operator commands 1: Bypass spawn protection 2: Operator commands without moderation perms 3: Moderation commands 4: /stop command Set a Command's Permission Level public class MyCommandsMod implements DedicatedServerModInitializer { @Override public void onInitializeServer() { CommandRegistrationCallback.EVENT.register(dispatcher, dedicated -> { dispatcher.register( literal(\"mymodcommand\") .then(literal(\"subcommand\") .requires(scs -> scs.hasPermissionLevel(3)) .executes(ctx -> { ctx.getSource().getPlayer().sendMessage(new LiteralText(\"It works\"), false); return 1; }) ) ); }); } } .requires(scs -> scs.hasPermissionLevel(3)) This line means that only players with permission level 3 or greater can run the following parts of the tree Permission Nodes While the permission level system provides security, it does not provide flexibility for servers. For this reason, we use the Fabric Permissions API. It allows you to declare multiple permission nodes for your mod, and them to be used by any permission manager mod that supports it such as LuckPerms or PlayerRoles . Instead of .requires(scs -> scs.hasPermissionLevel(3)) , we can do .requires(Permissions.require(\"mymod.command.mymodcommand.subcommand\", 3)) This line requires that the player have permission level 3 or the permission node of the name mymod.command.mymodcommand.subcommand Checking permission nodes outside of commands public class PermissionUtils { public boolean hasPermissionOrNode(ServerPlayerEntity player, int i, String node) { return Permissions.check(player, node, i); } } This code sample will return whether the player has a permission node or has permission level i You have now added permissions checks to your code! For more information, read the usage page on Fabric Permission API.","title":"Permissions"},{"location":"permissions/#permissions","text":"This tutorial shows how to handle and check permissions.","title":"Permissions"},{"location":"permissions/#setup","text":"You will need to have set up the Fabric Permissions API in your environment. See the libraries page","title":"Setup"},{"location":"permissions/#command-permissions","text":"Here is our command without a permission check: public class MyCommandsMod implements DedicatedServerModInitializer { @Override public void onInitializeServer() { CommandRegistrationCallback.EVENT.register(dispatcher, dedicated -> { dispatcher.register( literal(\"mymodcommand\") .then(literal(\"subcommand\") .executes(ctx -> { ctx.getSource().getPlayer().sendMessage(new LiteralText(\"It works\"), false); return 1; }) ) ); }); } } This allows any player on the server to use /mymodcommand . But in many cases, we want to restrict who can run the command","title":"Command Permissions"},{"location":"permissions/#permission-levels","text":"Every player has a permission level. Here is a non-extensive list of standard values: Standard player: 0 Command blocks: 2 Operator: Specified in server.properties , default 4","title":"Permission Levels"},{"location":"permissions/#what-do-the-levels-allow","text":"0: Normal non-operator commands 1: Bypass spawn protection 2: Operator commands without moderation perms 3: Moderation commands 4: /stop command","title":"What do the levels allow?"},{"location":"permissions/#set-a-commands-permission-level","text":"public class MyCommandsMod implements DedicatedServerModInitializer { @Override public void onInitializeServer() { CommandRegistrationCallback.EVENT.register(dispatcher, dedicated -> { dispatcher.register( literal(\"mymodcommand\") .then(literal(\"subcommand\") .requires(scs -> scs.hasPermissionLevel(3)) .executes(ctx -> { ctx.getSource().getPlayer().sendMessage(new LiteralText(\"It works\"), false); return 1; }) ) ); }); } } .requires(scs -> scs.hasPermissionLevel(3)) This line means that only players with permission level 3 or greater can run the following parts of the tree","title":"Set a Command's Permission Level"},{"location":"permissions/#permission-nodes","text":"While the permission level system provides security, it does not provide flexibility for servers. For this reason, we use the Fabric Permissions API. It allows you to declare multiple permission nodes for your mod, and them to be used by any permission manager mod that supports it such as LuckPerms or PlayerRoles . Instead of .requires(scs -> scs.hasPermissionLevel(3)) , we can do .requires(Permissions.require(\"mymod.command.mymodcommand.subcommand\", 3)) This line requires that the player have permission level 3 or the permission node of the name mymod.command.mymodcommand.subcommand","title":"Permission Nodes"},{"location":"permissions/#checking-permission-nodes-outside-of-commands","text":"public class PermissionUtils { public boolean hasPermissionOrNode(ServerPlayerEntity player, int i, String node) { return Permissions.check(player, node, i); } } This code sample will return whether the player has a permission node or has permission level i You have now added permissions checks to your code! For more information, read the usage page on Fabric Permission API.","title":"Checking permission nodes outside of commands"},{"location":"setup/","text":"Setup Prerequisites You will need: Java Development Kit Version 16 or newer IntelliJ IDEA Intermediate Java knowledge Git and basic git experience The Minecraft Development plugin for IntelliJ Basic JSON knowledge Download Create a new repository, either locally or on GitHub/GitLab. If you did not create it locally, go to file -> new from version control and clone the repo Download the code from the Fabric example mod repo . You will then need to copy the contents into your repository folder. Note about the Minecraft Development Plugin While you can handle the initial setup with the plugin, it has major bugs when it comes to 1.17 mod setup. You will also gain experience with Gradle and Loom this way Initialise your mod First, open up the gradle.properties file within IntelliJ. It will look something like this: # Done to increase the memory available to gradle. org.gradle.jvmargs=-Xmx1G # Fabric Properties # check these on https://fabricmc.net/versions.html minecraft_version=1.17.1 yarn_mappings=1.17.1+build.14 loader_version=0.11.6 # Mod Properties mod_version = 1.0.0 maven_group = com.example archives_base_name = fabric-example-mod # Dependencies fabric_version=0.37.0+1.17 First, you want to delete the dependencies section of your gradle.properties file. Open up the fabric versions page in your browser. Replace your # Fabric Properties section with the gradle.properties values found on the versions page. Next, you need to set your mod information. Set maven_group to io.github.yourusername and set archives_base_name to the name of your mod, in lower-case letters and without spaces. Fabric setup Now we have our Gradle set up, you will need to tell fabric about your mod. Navigate to your fabric.mod.json file found under src/main/resources It will look something like this: { \"schemaVersion\": 1, \"id\": \"modid\", \"version\": \"${version}\", \"name\": \"Example Mod\", \"description\": \"This is an example description! Tell everyone what your mod is about!\", \"authors\": [ \"Me!\" ], \"contact\": { \"homepage\": \"https://fabricmc.net/\", \"sources\": \"https://github.com/FabricMC/fabric-example-mod\" }, \"license\": \"CC0-1.0\", \"icon\": \"assets/modid/icon.png\", \"environment\": \"*\", \"entrypoints\": { \"main\": [ \"net.fabricmc.example.ExampleMod\" ] }, \"mixins\": [ \"modid.mixins.json\" ], \"depends\": { \"fabricloader\": \">=0.11.3\", \"fabric\": \"*\", \"minecraft\": \"1.17.x\", \"java\": \">=16\" }, \"suggests\": { \"another-mod\": \"*\" } } This files holds all the metadata about our mod, which Fabric uses to load the mod. Here is a list of fields and what you should change them to: id : The same value as you put for archives_base_name in gradle.properties . name : The formatted name of your mod. This can include spaces and capital letters. description : A short, formatted description of your mod authors : [ \"your_username\" ] Fill out the contact section with your relevant links, but you can remove it if you would like. license : The name and potentially version of the license of your choice. Although we strongly discourage keeping mods closed source, you may indicate this by omitting the field. environment : Leave at * if you want your mod to work on singleplayer (might cause issues), otherwise change it to server suggests : Feel free to remove this section depends : Will be covered in a tutorial showing how to use mod libraries. You can leave it as the default for now modid.mixins.json : Change it to <your_modid>.mixins.json You will also need to rename the modid.mixins.json file to <your_modid>.mixins.json , in your src/main/resources folder. Mixin file Your <your_modid>.mixins.json file should look like this: { \"required\": true, \"minVersion\": \"0.8\", \"package\": \"net.fabricmc.example.mixin\", \"compatibilityLevel\": \"JAVA_16\", \"mixins\": [ ], \"client\": [ \"ExampleMixin\" ], \"injectors\": { \"defaultRequire\": 1 } } Replace the net.fabricmc.example with your mod package, rename the client block to server and delete the \"ExampleMixin\" entry. Entrypoints Entrypoints are the classes where Fabric starts your mod - a piece of code that runs on game launch. More information can be found on the fabric wiki page . Dedicated server only Change the main entry in your entrypoints section to server You must now determine your package. This will most likely be the maven_group value from your gradle.properties , but with the name of your main class appended. An example would be: io.github.username.modname.ModName . After specifying this value, we now need to actually create the entrypoint. Delete the net folder found under src/main/java . Create a folder structure with your package, within the src/main/java directory. io.github.username.modname would become io/github/username/modname . Once you have created this folder, right click it in IntelliJ and press \"Create Java class\". The class name should be the value after your package specified in the entrypoints section. In the example case, it would be ModName . Just one more step now - we need to get Fabric to recognise our main class. Make the class you just created implement DedicatedServerModInitializer if you are targeting dedicated server only, or ModInitializer if you support singleplayer. Add System.out.println(\"MOD LOADED\") to the overridden method IntelliJ should prompt you to make. Run configurations Go to the top right-hand corner of IntelliJ, press \"Add Configuration\", then under \"application\" you will find Minecraft Server . Select that and press debug. You will need to agree to the EULA, but if all goes well your mod has been loaded! Export In the Gradle tab, choose build . You want the jar without -dev or -sources found in build/libs","title":"Setup"},{"location":"setup/#setup","text":"","title":"Setup"},{"location":"setup/#prerequisites","text":"You will need: Java Development Kit Version 16 or newer IntelliJ IDEA Intermediate Java knowledge Git and basic git experience The Minecraft Development plugin for IntelliJ Basic JSON knowledge","title":"Prerequisites"},{"location":"setup/#download","text":"Create a new repository, either locally or on GitHub/GitLab. If you did not create it locally, go to file -> new from version control and clone the repo Download the code from the Fabric example mod repo . You will then need to copy the contents into your repository folder.","title":"Download"},{"location":"setup/#note-about-the-minecraft-development-plugin","text":"While you can handle the initial setup with the plugin, it has major bugs when it comes to 1.17 mod setup. You will also gain experience with Gradle and Loom this way","title":"Note about the Minecraft Development Plugin"},{"location":"setup/#initialise-your-mod","text":"First, open up the gradle.properties file within IntelliJ. It will look something like this: # Done to increase the memory available to gradle. org.gradle.jvmargs=-Xmx1G # Fabric Properties # check these on https://fabricmc.net/versions.html minecraft_version=1.17.1 yarn_mappings=1.17.1+build.14 loader_version=0.11.6 # Mod Properties mod_version = 1.0.0 maven_group = com.example archives_base_name = fabric-example-mod # Dependencies fabric_version=0.37.0+1.17 First, you want to delete the dependencies section of your gradle.properties file. Open up the fabric versions page in your browser. Replace your # Fabric Properties section with the gradle.properties values found on the versions page. Next, you need to set your mod information. Set maven_group to io.github.yourusername and set archives_base_name to the name of your mod, in lower-case letters and without spaces.","title":"Initialise your mod"},{"location":"setup/#fabric-setup","text":"Now we have our Gradle set up, you will need to tell fabric about your mod. Navigate to your fabric.mod.json file found under src/main/resources It will look something like this: { \"schemaVersion\": 1, \"id\": \"modid\", \"version\": \"${version}\", \"name\": \"Example Mod\", \"description\": \"This is an example description! Tell everyone what your mod is about!\", \"authors\": [ \"Me!\" ], \"contact\": { \"homepage\": \"https://fabricmc.net/\", \"sources\": \"https://github.com/FabricMC/fabric-example-mod\" }, \"license\": \"CC0-1.0\", \"icon\": \"assets/modid/icon.png\", \"environment\": \"*\", \"entrypoints\": { \"main\": [ \"net.fabricmc.example.ExampleMod\" ] }, \"mixins\": [ \"modid.mixins.json\" ], \"depends\": { \"fabricloader\": \">=0.11.3\", \"fabric\": \"*\", \"minecraft\": \"1.17.x\", \"java\": \">=16\" }, \"suggests\": { \"another-mod\": \"*\" } } This files holds all the metadata about our mod, which Fabric uses to load the mod. Here is a list of fields and what you should change them to: id : The same value as you put for archives_base_name in gradle.properties . name : The formatted name of your mod. This can include spaces and capital letters. description : A short, formatted description of your mod authors : [ \"your_username\" ] Fill out the contact section with your relevant links, but you can remove it if you would like. license : The name and potentially version of the license of your choice. Although we strongly discourage keeping mods closed source, you may indicate this by omitting the field. environment : Leave at * if you want your mod to work on singleplayer (might cause issues), otherwise change it to server suggests : Feel free to remove this section depends : Will be covered in a tutorial showing how to use mod libraries. You can leave it as the default for now modid.mixins.json : Change it to <your_modid>.mixins.json You will also need to rename the modid.mixins.json file to <your_modid>.mixins.json , in your src/main/resources folder.","title":"Fabric setup"},{"location":"setup/#mixin-file","text":"Your <your_modid>.mixins.json file should look like this: { \"required\": true, \"minVersion\": \"0.8\", \"package\": \"net.fabricmc.example.mixin\", \"compatibilityLevel\": \"JAVA_16\", \"mixins\": [ ], \"client\": [ \"ExampleMixin\" ], \"injectors\": { \"defaultRequire\": 1 } } Replace the net.fabricmc.example with your mod package, rename the client block to server and delete the \"ExampleMixin\" entry.","title":"Mixin file"},{"location":"setup/#entrypoints","text":"Entrypoints are the classes where Fabric starts your mod - a piece of code that runs on game launch. More information can be found on the fabric wiki page .","title":"Entrypoints"},{"location":"setup/#dedicated-server-only","text":"Change the main entry in your entrypoints section to server You must now determine your package. This will most likely be the maven_group value from your gradle.properties , but with the name of your main class appended. An example would be: io.github.username.modname.ModName . After specifying this value, we now need to actually create the entrypoint. Delete the net folder found under src/main/java . Create a folder structure with your package, within the src/main/java directory. io.github.username.modname would become io/github/username/modname . Once you have created this folder, right click it in IntelliJ and press \"Create Java class\". The class name should be the value after your package specified in the entrypoints section. In the example case, it would be ModName . Just one more step now - we need to get Fabric to recognise our main class. Make the class you just created implement DedicatedServerModInitializer if you are targeting dedicated server only, or ModInitializer if you support singleplayer. Add System.out.println(\"MOD LOADED\") to the overridden method IntelliJ should prompt you to make.","title":"Dedicated server only"},{"location":"setup/#run-configurations","text":"Go to the top right-hand corner of IntelliJ, press \"Add Configuration\", then under \"application\" you will find Minecraft Server . Select that and press debug. You will need to agree to the EULA, but if all goes well your mod has been loaded!","title":"Run configurations"},{"location":"setup/#export","text":"In the Gradle tab, choose build . You want the jar without -dev or -sources found in build/libs","title":"Export"},{"location":"config/gson_config/","text":"Config files Sooner or later you'll get to the point where you'd like to make certain things toggleable. For such things, we can utilize included Gson library to read and write json configs. Why gson? As mentioned above, Gson is already available in vanilla minecraft, meaning that you won't need any extra dependencies. If you don't need anything special and you're fine with json format, Gson will probably cover your needs. Not to mention that it will auto add the missing fields when updating the config without need to overwrite old values. Config structure We'll use a custom config class that has fields that user / admin will be able to change. See below example. public class MyModConfig { public float activationRange = 8.0F; public boolean show = true; public String message = \"This is a config guide.\"; } We can access our config values like this: MyModConfig config = new MyModConfig(); if(config.show) System.out.println(config.message); config.show = false; // Do other stuff with values ... We can present the config object in the following json structure. { \"activationRange\": 8.0, \"show\": true, \"message\": \"This is a config guide.\" } Saving, reading and parsing If config only exists in our memory, it's not that usefull, as changes will be reset after server restart. If we want to make them permanent, we should write the config to a file. public class MyModConfig { private static final Gson gson = new GsonBuilder() .setPrettyPrinting() // Makes the json use new lines instead of being a \"one-liner\" .serializeNulls() // Makes fields with `null` value to be written as well. .disableHtmlEscaping() // We'll be able to use custom chars without them being saved differently .create(); // Config values public float activationRange = 8.0F; public boolean show = true; public String message = \"This is a config guide.\"; // Reading and saving /** * Loads config file. * * @param file file to load the config file from. * @return MyModConfig object */ public static MyModConfig loadConfigFile(File file) { MyModConfig config = null; if (file.exists()) { // An existing config is present, we should use its values try (BufferedReader fileReader = new BufferedReader( new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8) )) { // Parses the config file and puts the values into config object config = gson.fromJson(fileReader, MyModConfig.class); } catch (IOException e) { throw new RuntimeException(\"[MyMod] Problem occurred when trying to load config: \", e); } } // gson.fromJson() can return null if file is empty if (config == null) { config = new MyModConfig(); } // Saves the file in order to write new fields if they were added config.saveConfigFile(file); return config; } /** * Saves the config to the given file. * * @param file file to save config to */ public void saveConfigFile(File file) { try (Writer writer = new OutputStreamWriter(new FileOutputStream(file), StandardCharsets.UTF_8)) { gson.toJson(this, writer); } catch (IOException e) { e.printStackTrace(); } } } Now that we have those new methods, we should use the following code to load the config. File configFile = FabricLoader.getInstance().getConfigDir().resolve(\"my_mod_config.json\"); MyModConfig config = MyModConfig.loadConfigFile(configFile); if(config.show) System.out.println(config.message); config.show = false; // We can save it now // If you'd like, you can also save the file parameter when loading config.save(configFile); // Do other stuff with values ... This will automatically create new config file or read the existing one. Nested classes Creating nested structures is really simple. All you need to have is another static inner class and a new object for it. See the example below. public class MyModConfig { public float activationRange = 8.0F; public boolean show = true; public String message = \"This is a config guide.\"; public NestedValues nested = new NestedValues(); public static class NestedValues { public String message = \"This is a another message.\"; } } And its json counterpart: { \"activationRange\": 8.0, \"show\": true, \"message\": \"This is a config guide.\", \"nested\": { \"message\": \"This is a another message.\" } } Arrays To create a json array, you can use ArrayList<> class from java. public class MyModConfig { public float activationRange = 8.0F; public boolean show = true; public String message = \"This is a config guide.\"; public NestedValues nested = new NestedValues(); public static class NestedValues { public String message = \"This is a another message.\"; } public List<String> randomQuestions = new ArrayList<>(Arrays.asList( \"Why no forge port?\", \"When quilt?\", \"Tiny potato or tiny pumpkin?\", \"What is minecraft?\" // How dare you )); } And its json counterpart: { \"activationRange\": 8.0, \"show\": true, \"message\": \"This is a config guide.\", \"nested\": { \"message\": \"This is a another message.\" }, \"randomQuestions\": [ \"Why no forge port?\", \"When quilt?\", \"Tiny potato or tiny pumpkin?\", \"What is minecraft?\" ] } Naming the fields differently Json structure doesn't limit us as much as java when it comes to naming fields. Luckily, we can overcome this problem by using @SerializedName annotation on fields to change how they're written in the file. public class MyModConfig { @SerializedName(\"activation range\") public float activationRange = 8.0F; @SerializedName(\"Show config message.\") public boolean show = true; @SerializedName(\"config_message\") public String message = \"This is a config guide.\"; } The above code will result in the following json: { \"activation range\": 8.0, \"Show config message.\": true, \"config_message\": \"This is a config guide.\" } Poor-man's comments With the above technique we can even add \"comments\" to our config. Sure, they won't be \"perfect json5\" comments, but ... they'll still be useful for the end user. Comments must be unique, as they act like json fields. public class MyModConfig { // Naming comments in style `_comment_` + `field name` @SerializedName(\"// When to activate feature xyz.\") public final String _comment_activationRange = \"(default: 8.0)\"; @SerializedName(\"activation_range\") public float activationRange = 8.0F; @SerializedName(\"// Whether to show config message.\") public final String _comment_show = \"(default: true)\"; @SerializedName(\"show_config_message.\") public boolean show = true; @SerializedName(\"// Which message to print out\") public final String _comment_message0 = \"\"; @SerializedName(\"// if above option is enabled\") public final String _comment_message1 = \"(default: 'This is a config guide.')\"; @SerializedName(\"config_message\") public String message = \"This is a config guide.\"; } This will be saved as the following json: { \"// When to activate feature xyz.\": \"(default: 8.0)\", \"activation_range\": 8.0, \"// Whether to show config message.\": \"(default: true)\", \"show_config_message.\": true, \"// Which message to print out\": \"\", \"// if above option is enabled\": \"(default: 'This is a config guide.')\", \"config_message\": \"This is a config guide.\" }","title":"Using gson"},{"location":"config/gson_config/#config-files","text":"Sooner or later you'll get to the point where you'd like to make certain things toggleable. For such things, we can utilize included Gson library to read and write json configs.","title":"Config files"},{"location":"config/gson_config/#why-gson","text":"As mentioned above, Gson is already available in vanilla minecraft, meaning that you won't need any extra dependencies. If you don't need anything special and you're fine with json format, Gson will probably cover your needs. Not to mention that it will auto add the missing fields when updating the config without need to overwrite old values.","title":"Why gson?"},{"location":"config/gson_config/#config-structure","text":"We'll use a custom config class that has fields that user / admin will be able to change. See below example. public class MyModConfig { public float activationRange = 8.0F; public boolean show = true; public String message = \"This is a config guide.\"; } We can access our config values like this: MyModConfig config = new MyModConfig(); if(config.show) System.out.println(config.message); config.show = false; // Do other stuff with values ... We can present the config object in the following json structure. { \"activationRange\": 8.0, \"show\": true, \"message\": \"This is a config guide.\" }","title":"Config structure"},{"location":"config/gson_config/#saving-reading-and-parsing","text":"If config only exists in our memory, it's not that usefull, as changes will be reset after server restart. If we want to make them permanent, we should write the config to a file. public class MyModConfig { private static final Gson gson = new GsonBuilder() .setPrettyPrinting() // Makes the json use new lines instead of being a \"one-liner\" .serializeNulls() // Makes fields with `null` value to be written as well. .disableHtmlEscaping() // We'll be able to use custom chars without them being saved differently .create(); // Config values public float activationRange = 8.0F; public boolean show = true; public String message = \"This is a config guide.\"; // Reading and saving /** * Loads config file. * * @param file file to load the config file from. * @return MyModConfig object */ public static MyModConfig loadConfigFile(File file) { MyModConfig config = null; if (file.exists()) { // An existing config is present, we should use its values try (BufferedReader fileReader = new BufferedReader( new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8) )) { // Parses the config file and puts the values into config object config = gson.fromJson(fileReader, MyModConfig.class); } catch (IOException e) { throw new RuntimeException(\"[MyMod] Problem occurred when trying to load config: \", e); } } // gson.fromJson() can return null if file is empty if (config == null) { config = new MyModConfig(); } // Saves the file in order to write new fields if they were added config.saveConfigFile(file); return config; } /** * Saves the config to the given file. * * @param file file to save config to */ public void saveConfigFile(File file) { try (Writer writer = new OutputStreamWriter(new FileOutputStream(file), StandardCharsets.UTF_8)) { gson.toJson(this, writer); } catch (IOException e) { e.printStackTrace(); } } } Now that we have those new methods, we should use the following code to load the config. File configFile = FabricLoader.getInstance().getConfigDir().resolve(\"my_mod_config.json\"); MyModConfig config = MyModConfig.loadConfigFile(configFile); if(config.show) System.out.println(config.message); config.show = false; // We can save it now // If you'd like, you can also save the file parameter when loading config.save(configFile); // Do other stuff with values ... This will automatically create new config file or read the existing one.","title":"Saving, reading and parsing"},{"location":"config/gson_config/#nested-classes","text":"Creating nested structures is really simple. All you need to have is another static inner class and a new object for it. See the example below. public class MyModConfig { public float activationRange = 8.0F; public boolean show = true; public String message = \"This is a config guide.\"; public NestedValues nested = new NestedValues(); public static class NestedValues { public String message = \"This is a another message.\"; } } And its json counterpart: { \"activationRange\": 8.0, \"show\": true, \"message\": \"This is a config guide.\", \"nested\": { \"message\": \"This is a another message.\" } }","title":"Nested classes"},{"location":"config/gson_config/#arrays","text":"To create a json array, you can use ArrayList<> class from java. public class MyModConfig { public float activationRange = 8.0F; public boolean show = true; public String message = \"This is a config guide.\"; public NestedValues nested = new NestedValues(); public static class NestedValues { public String message = \"This is a another message.\"; } public List<String> randomQuestions = new ArrayList<>(Arrays.asList( \"Why no forge port?\", \"When quilt?\", \"Tiny potato or tiny pumpkin?\", \"What is minecraft?\" // How dare you )); } And its json counterpart: { \"activationRange\": 8.0, \"show\": true, \"message\": \"This is a config guide.\", \"nested\": { \"message\": \"This is a another message.\" }, \"randomQuestions\": [ \"Why no forge port?\", \"When quilt?\", \"Tiny potato or tiny pumpkin?\", \"What is minecraft?\" ] }","title":"Arrays"},{"location":"config/gson_config/#naming-the-fields-differently","text":"Json structure doesn't limit us as much as java when it comes to naming fields. Luckily, we can overcome this problem by using @SerializedName annotation on fields to change how they're written in the file. public class MyModConfig { @SerializedName(\"activation range\") public float activationRange = 8.0F; @SerializedName(\"Show config message.\") public boolean show = true; @SerializedName(\"config_message\") public String message = \"This is a config guide.\"; } The above code will result in the following json: { \"activation range\": 8.0, \"Show config message.\": true, \"config_message\": \"This is a config guide.\" }","title":"Naming the fields differently"},{"location":"config/gson_config/#poor-mans-comments","text":"With the above technique we can even add \"comments\" to our config. Sure, they won't be \"perfect json5\" comments, but ... they'll still be useful for the end user. Comments must be unique, as they act like json fields. public class MyModConfig { // Naming comments in style `_comment_` + `field name` @SerializedName(\"// When to activate feature xyz.\") public final String _comment_activationRange = \"(default: 8.0)\"; @SerializedName(\"activation_range\") public float activationRange = 8.0F; @SerializedName(\"// Whether to show config message.\") public final String _comment_show = \"(default: true)\"; @SerializedName(\"show_config_message.\") public boolean show = true; @SerializedName(\"// Which message to print out\") public final String _comment_message0 = \"\"; @SerializedName(\"// if above option is enabled\") public final String _comment_message1 = \"(default: 'This is a config guide.')\"; @SerializedName(\"config_message\") public String message = \"This is a config guide.\"; } This will be saved as the following json: { \"// When to activate feature xyz.\": \"(default: 8.0)\", \"activation_range\": 8.0, \"// Whether to show config message.\": \"(default: true)\", \"show_config_message.\": true, \"// Which message to print out\": \"\", \"// if above option is enabled\": \"(default: 'This is a config guide.')\", \"config_message\": \"This is a config guide.\" }","title":"Poor-man's comments"}]}